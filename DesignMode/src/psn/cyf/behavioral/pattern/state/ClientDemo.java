package psn.cyf.behavioral.pattern.state;

/**
 * 状态 模式（ State Pattern） 又称 为 状态 对象 模式， 该 模式 允许
 * 一个 对象 在 其内 部 状态 改变 时 改变 其 行为。
 *当 一个 对象 内在 状态 改变 时 允许 改变 行为， 这个 对象 看起来
 * 像 改 变了 其 类型。 状态 模式 的 核心 是 封装， 状态 的 变更
 * 引起 行为 的 变动， 从外部 看来 就 好像 该 对象 对应 的 类 发
 * 生 改变 一样。
 *状态 模式 涉及 以下 3 个 角色。
 * ■ 　 抽象 状态（ State） 角色： 该 角色 用以 封装 环境 对象
 * 的 一个 特定 状态 所 对应 的 行为。
 *■ 　 具体 状态（ Concrete State） 角色： 该 角色 实现 环境
 * 的 一个 状态 所 对应 的 行为。
 * ■ 　 环境（ Context） 角色： 该 角色 定义 客户 端 需要 的
 * 接口， 并 负责 具体 状态 的 切换。 它 会 保留 一个 具体 状态
 * 类 的 实例， 该 实例 给出 环境 对象 的 现有 状态。
 *1． 状态 模式 的 优缺点 状态 模式 的 优点 有 以下 几个 方面。
 * ■ 　 结构 清晰。
 * ■ 　 遵循 设计 原则。
 * ■ 　 封装 性 非常好。
 * 状态 模式 的 缺点 如下。
 * ■ 　 子类 太多， 不易 管理。
 * 2． 状态 模式 的 效果 状态 模式 的 效果 如下 所示。
 * ■ 　 状态 模式 需要 对 每一个 系统 可能 取得 的 状态 创建 一个
 * 状态 类 的 子类。 当 系统 的 状态 变化 时， 系统 便 改变 所选 的
 * 子类。 所有 与 一个 特定 的 状态 有关 的 行为 都被 包装 到 一个
 * 特定 的 对象 里面， 使得 行为的 定义 局域 化。 因为 同样 的 原因，
 * 如果 有 新的 状态 以及 它 对应 的 行为 需要 定义 时， 可以 很
 * 方便 地 通过 设立 新的 子类 的 方式 加到 系统 里， 不需要 改动
 * 其 他的 类。
 * ■ 　 由于 每一个 状态 都被 包装 到了 类 里面， 就可以 不必
 * 采用 过程 性的 处理 方式， 使用 长篇累牍 的 条件 转移 语句。
 * ■ 　 使用 状态 模式 使 系统 状态 的 变化 变得 很 明显。 由
 * 于 不用 一些 属性 来 指明 系统 所处 的 状态， 因此， 就不 用
 * 担心 修改 这些 属性 不当 而 造成 的 错误。
 *■ 　 可以 在 系统 的 不同 部分 使用 相同 的 一些 状态 类 的 对象。
 * 这种 共享 对象 的 方法 是与 享 元 模式 相符合 的， 事实上， 此时 这些
 * 状态 对象 基本上 是 只有 行为 而 没有 内部 状态 的 享 元。
 * ■ 　 状态 模式 会 造成 大量 的 小 状态 类， 但是 可以 使 程序
 * 免于 大量 的 条件 转移 语句， 使 程序 实际上 更易 于 维护。
 * ■ 　 系统 所选 的 状态 子类 均 是 从 一个 抽象 状态 类 或 接口 继承
 * 而来， Java 语言 的 特性 使得 在 Java 语言 中 使用 状态 模式
 * 较为 安全， 多 态 性 原则 是 状态 模式 的 核心。
 *3． 状态 模式 的 使用 场景 使用 状态 模式 的 典型 场景 如下。
 *  ■ 　 对象 的 行为 依赖于 它 所处 的 状态， 即 行为 随 状态 改变 而 改变 的 场景。
 *  ■ 　 对象 在某 个 方法 里 依赖于 一 重 或 多重 条件 分支 语句， 此时 可以 使用
 *  状态 模式 将 分支 语句 中的 每一个 分支 都 包装 到 一个 单独 的 类 中， 使得
 *  这些 条件 分支 语句 能够 以 类 的 方式 独立 存在 和 演化。 如此， 维护 这些
 *  独立 的 类 就不 再 影响 到 系统 的 其他 部分。
 *
 */
public class ClientDemo {
    public static void main(String[] args) {
        TV tv=new TV();
        //换台
        tv.disCCTV1();
        tv.disCCTV2();
        tv.disCCTV3();

    }
}
